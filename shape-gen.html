<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Arcana Pattern Workshop (Points Only)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root {
    --bg: #0e1116;
    --panel: #151a23;
    --accent: #4da6ff;
    --muted: #8aa0b2;
    --text: #e8eef6;
    --danger: #ff4d6d;
  }
  html, body { margin:0; height:100%; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto; }
  .layout { display:grid; grid-template-columns: 360px 1fr; grid-template-rows: 1fr; height:100%; }
  .panel { background:var(--panel); padding:16px; border-right:1px solid #1e2531; overflow:auto; }
  .panel h2 { margin: 0 0 12px; font-size:18px; }
  .panel h3 { margin: 18px 0 8px; font-size:14px; color:var(--muted); text-transform:uppercase; letter-spacing: .06em; }
  .row { display:flex; align-items:center; gap:10px; margin:8px 0; }
  .row label { flex:0 0 120px; color:#bcd; font-size:12px; }
  .row input[type="text"], .row input[type="number"] { width:100%; padding:8px; background:#0d1117; border:1px solid #232b36; color:#def; border-radius:8px; }
  .btn { display:inline-flex; align-items:center; justify-content:center; padding:8px 12px; background:#1a2230; color:#e8eef6; border:1px solid #2a3342; border-radius:8px; cursor:pointer; }
  .btn:hover { background:#202a3b; }
  .btn.primary { background:var(--accent); border-color:#2d7bd1; color:#03121f; font-weight:700; }
  .btn.danger { background: #2b1620; border-color:#44131f; color: #ffd7df; }
  .muted { color: var(--muted); font-size:12px; }
  .code { background:#0b0f14; border:1px solid #1e2531; border-radius:10px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#bde; white-space:pre; user-select:text; }
  .tiny { font-size:11px; color:#9bb; }
  canvas { display:block; width:100%; height:100%; background:#0b0f14; cursor:crosshair; }
  .toolbar { display:flex; gap:8px; flex-wrap:wrap; }
  .pill { padding:5px 9px; border:1px solid #2a3342; border-radius:999px; background:#10151d; color:#cfe; cursor:pointer; }
  .pill.active { background:#20304a; border-color:#38527a; }
  .section { padding:10px 0; border-top:1px dashed #223; margin-top:10px; }
  textarea.code { width:100%; height:140px; resize:vertical; }
</style>
</head>
<body>
<div class="layout">
  <div class="panel">
    <h2>Pattern Workshop</h2>

    <div class="toolbar">
      <div class="pill" id="snapGrid">Snap: <span>On</span></div>
      <div class="pill" id="normalize">Normalize Export</div>
      <div class="pill danger" id="clear">Clear</div>
    </div>

    <div class="section">
      <h3>Canvas</h3>
      <div class="row">
        <label>Unit scale</label>
        <input id="unitScale" type="number" step="0.1" value="100"/>
      </div>
      <div class="row">
        <span class="muted tiny">
          Click to add. Drag on empty to box-select (Shift=add, Ctrl/Cmd=toggle). Alt+drag to pan. Wheel=zoom.
          Copy/Paste. Undo/Redo. <b>Hold R</b> and drag to rotate selection (wheel+R = fine; Shift while R = 15° snap).
        </span>
      </div>
    </div>

    <div class="section">
      <h3>Import</h3>
      <div class="row" style="gap:6px">
        <input type="file" id="importFile" accept=".ts,.js,.txt"/>
        <button class="btn" id="importFileBtn">Import File</button>
        <button class="btn" id="importSample">Sample →</button>
      </div>
      <div class="row">
        <textarea id="importText" class="code" placeholder="Paste a pattern module here (must contain a SEEDS array of new THREE.Vector2(x, y) entries)…"></textarea>
      </div>
      <div class="row">
        <button class="btn primary" id="loadFromText">Load From Text</button>
      </div>
      <div class="tiny">
        Accepts modules in the same format this tool exports (no <code>id</code>/<code>label</code>): a <code>SEEDS</code> array and a default-exported <code>pattern</code>. Older modules with <code>id</code>/<code>label</code> also work—only <code>SEEDS</code> is read.
      </div>
    </div>

    <div class="section">
      <h3>Export</h3>
      <div class="row" style="gap:8px">
        <button class="btn primary" id="export">Export TypeScript</button>
        <button class="btn" id="copy">Copy</button>
      </div>
      <div class="row">
        <div class="code" id="out" style="width:100%; height:280px; overflow:auto;"></div>
      </div>
      <div class="tiny">
        Save to <code>src/features/cardGroup/patterns/custom/&lt;name&gt;.ts</code>.
      </div>
    </div>
  </div>

  <canvas id="cv"></canvas>
</div>

<script>
(function(){
  /*** Canvas & state ***/
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  let W=0,H=0,dpr=1;
  function resize(){ dpr=window.devicePixelRatio||1; W=cv.clientWidth*dpr; H=cv.clientHeight*dpr; cv.width=W; cv.height=H; draw(); }
  new ResizeObserver(resize).observe(cv);

  const ui = {
    snap: true,
    normalize: false,
    unit: 100, // px per local unit (drawing only)
    pan: {x:0,y:0},
    zoom: 1,
    sel: -1,
    hover: -1,
  };

  const MARQUEE_CLICK_PX = 4; // px threshold to treat drag as click-add

  const pointDots = [];         // [[x,y],...]
  const selected = new Set();   // indices

  // History (undo/redo)
  const MAX_HIST = 200;
  const undoStack = [];
  const redoStack = [];
  function deepCopyPts(arr){ return arr.map(([x,y])=>[x,y]); }
  function snapshot(pushRedo=false){
    const state = { pts: deepCopyPts(pointDots), sel: [...selected] };
    if (pushRedo) redoStack.push(state);
    else {
      undoStack.push(state);
      if (undoStack.length>MAX_HIST) undoStack.shift();
      redoStack.length = 0;
    }
  }
  function restore(state){
    pointDots.length = 0; state.pts.forEach(p=>pointDots.push([p[0],p[1]]));
    selected.clear(); state.sel.forEach(i=>selected.add(i));
    ui.sel = -1; ui.hover = -1;
    draw(); updateExport();
  }
  function canUseKeysTarget(e){
    const t = e.target;
    return !(t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable));
  }

  /*** DOM ***/
  const $snap = document.getElementById('snapGrid');
  const $norm = document.getElementById('normalize');
  const $unit = document.getElementById('unitScale');
  const $unitPx = document.getElementById('unitPx');
  const $out = document.getElementById('out');
  const $importFile = document.getElementById('importFile');
  const $importFileBtn = document.getElementById('importFileBtn');
  const $importText = document.getElementById('importText');
  const $loadFromText = document.getElementById('loadFromText');
  const $importSample = document.getElementById('importSample');

  document.getElementById('clear').onclick = () => { snapshot(); pointDots.length = 0; selected.clear(); ui.sel=-1; draw(); updateExport(); };
  document.getElementById('export').onclick = updateExport;
  document.getElementById('copy').onclick = () => { const s = $out.textContent || ''; navigator.clipboard.writeText(s).catch(()=>{}); };

  $snap.addEventListener('click', ()=>{ ui.snap=!ui.snap; $snap.querySelector('span').textContent=ui.snap?'On':'Off'; draw(); });
  $norm.addEventListener('click', ()=>{ ui.normalize=!ui.normalize; $norm.classList.toggle('active', ui.normalize); updateExport(); });
  $unit.addEventListener('input', ()=>{ ui.unit=Math.max(10,+$unit.value||100); $unitPx.textContent = ui.unit; draw(); });

  $importFileBtn.addEventListener('click', ()=> $importFile.click());
  $importFile.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const text = await f.text();
    $importText.value = text;
    loadSeedsFromText(text, true);
  });
  $loadFromText.addEventListener('click', ()=> loadSeedsFromText($importText.value||'', true));
  $importSample.addEventListener('click', ()=> {
    const sample = `// AUTO-GENERATED BY shape-gen.html (Points mode)
import * as THREE from 'three';
import type { Pattern } from '@/features/cardGroup/patterns';

const SEEDS: THREE.Vector2[] = [
  new THREE.Vector2( 1.50000,  2.50000),
  new THREE.Vector2(-1.50000,  2.50000),
  new THREE.Vector2( 0.00000, -2.50000),
  new THREE.Vector2( 0.00000,  1.00000),
  new THREE.Vector2( 0.50000,  2.00000),
  new THREE.Vector2(-0.50000,  2.00000),
  new THREE.Vector2( 2.30000,  2.00000)
];

const pattern: Pattern = {
  fixedCount: SEEDS.length,
  sample() { return { positions: SEEDS.map(v => new THREE.Vector3(v.x, v.y, 0)) }; }
};
export default pattern;`;
    $importText.value = sample;
    loadSeedsFromText(sample, true);
  });

  /*** Helpers: screen<->local ***/
  function toScreen([x,y]) {
    const ox = W*0.5 + ui.pan.x*dpr, oy = H*0.5 + ui.pan.y*dpr;
    return [ox + x*ui.unit*ui.zoom, oy - y*ui.unit*ui.zoom];
  }
  function toLocal([sx,sy]) {
    const ox = W*0.5 + ui.pan.x*dpr, oy = H*0.5 + ui.pan.y*dpr;
    const x = (sx-ox)/(ui.unit*ui.zoom), y = -(sy-oy)/(ui.unit*ui.zoom);
    return [x,y];
  }
  function snapLocal([x,y]) {
    if (!ui.snap) return [x,y];
    const g = 0.1; // 0.1 units
    return [Math.round(x/g)*g, Math.round(y/g)*g];
  }

  function isSelected(i){ return selected.has(i); }
  function setSelection(indices){ selected.clear(); indices.forEach(i=>selected.add(i)); }
  function addSelection(indices){ indices.forEach(i=>selected.add(i)); }
  function toggleSelection(indices){ indices.forEach(i=> selected.has(i)? selected.delete(i) : selected.add(i)); }
  function selectedIndices(){ return [...selected].sort((a,b)=>a-b); }
  function selectionBBoxScreen(){
    const pts = selectedIndices().map(i=>toScreen(pointDots[i]));
    if (!pts.length) return null;
    let minX=+1e9,minY=+1e9,maxX=-1e9,maxY=-1e9;
    for (const [x,y] of pts){ if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y; }
    return {minX,minY,maxX,maxY};
  }

  /*** Input ***/
  let dragging=false, draggingCanvas=false, draggingSelection=false, dragIdx=-1;
  let lastMouse=[0,0];
  let dragStartLocal=[0,0];
  let dragOriginals=null; // [{k, p:[x,y]},...]

  // Marquee (axis-aligned)
  let marqueeActive=false, marqueeMode='replace', marqueeStart=[0,0], marqueeEnd=[0,0];

  // Rotation of selected dots
  let rotateActive=false;
  let rotatePivotLocal=[0,0];
  let rotateStartAngle=0;     // in local space
  let rotateDelta=0;          // current delta
  let rotateOriginals=null;   // [{k, p:[x,y]}] originals for selected
  let preRotateState=null;    // snapshot to restore on cancel

  function startRotate(){
    const idx = selectedIndices();
    if (!idx.length) return;
    // centroid pivot
    let cx=0, cy=0;
    for (const i of idx){ cx+=pointDots[i][0]; cy+=pointDots[i][1]; }
    cx/=idx.length; cy/=idx.length;
    rotatePivotLocal=[cx,cy];

    rotateOriginals = idx.map(k=>({k, p:[...pointDots[k]]}));
    preRotateState = { pts: deepCopyPts(pointDots), sel:[...selected] };
    snapshot(); // push pre-rotate to undo
    // reference angle from pivot to current mouse (local)
    const mouseLocal = toLocal(lastMouse);
    rotateStartAngle = Math.atan2(mouseLocal[1]-cy, mouseLocal[0]-cx);
    rotateDelta = 0;
    rotateActive = true;
    draw();
  }
  function endRotate(commit=true){
    if (!rotateActive) return;
    if (!commit && preRotateState){ // cancel
      restore(preRotateState);
    }
    rotateActive=false;
    rotateOriginals=null;
    preRotateState=null;
    draw(); updateExport();
  }
  function applyRotate(delta){
    if (!rotateOriginals) return;
    const [cx,cy] = rotatePivotLocal;
    const c = Math.cos(delta), s = Math.sin(delta);
    for (const {k,p:[x0,y0]} of rotateOriginals){
      const dx=x0-cx, dy=y0-cy;
      const x = cx + dx*c - dy*s;
      const y = cy + dx*s + dy*c;
      pointDots[k] = [x,y]; // no snapping during rotation
    }
  }

  cv.addEventListener('mousedown', (e)=>{
    const p=[e.offsetX*dpr,e.offsetY*dpr];
    lastMouse=p;

    if (e.altKey){ draggingCanvas=true; return;}

    const i = pick(p, pointDots);
    const onPoint = i>=0;

    if (onPoint){
      if (e.shiftKey){
        snapshot(); if (isSelected(i)) selected.delete(i); else selected.add(i);
        draw(); return;
      }
      if (!isSelected(i)){ snapshot(); setSelection([i]); }
      dragging=true; draggingSelection=true; dragIdx=i;
      dragStartLocal = toLocal(p);
      dragOriginals = selectedIndices().map(k=>({k, p:[...pointDots[k]]}));
      draw();
    } else {
      // start marquee
      marqueeActive=true;
      marqueeStart=p; marqueeEnd=p;
      marqueeMode = e.shiftKey ? 'add' : ((e.ctrlKey||e.metaKey) ? 'toggle' : 'replace');
      ui.sel=-1; ui.hover=-1;
      draw();
    }
  });

  cv.addEventListener('mousemove', (e)=>{
    const p=[e.offsetX*dpr,e.offsetY*dpr];

    if (draggingCanvas){
      ui.pan.x += (p[0]-lastMouse[0])/dpr;
      ui.pan.y += (p[1]-lastMouse[1])/dpr;
      draw(); lastMouse=p; return;
    }

    if (rotateActive){
      const mL = toLocal(p);
      const aNow = Math.atan2(mL[1]-rotatePivotLocal[1], mL[0]-rotatePivotLocal[0]);
      let d = aNow - rotateStartAngle;
      // optional snapping with Shift (15°)
      if (e.shiftKey){
        const step = Math.PI/12;
        d = Math.round(d/step)*step;
      }
      rotateDelta = d;
      applyRotate(rotateDelta);
      draw(); updateExport();
      lastMouse=p; return;
    }

    if (dragging && draggingSelection && dragOriginals){
      const L = toLocal(p);
      const dx = L[0]-dragStartLocal[0], dy = L[1]-dragStartLocal[1];
      for (const {k,p:op} of dragOriginals){
        const S = ui.snap? snapLocal([op[0]+dx, op[1]+dy]) : [op[0]+dx, op[1]+dy];
        pointDots[k]=S;
      }
      draw(); updateExport();
      lastMouse=p; return;
    }

    if (marqueeActive){
      marqueeEnd = p;
      draw();
      lastMouse=p; return;
    }

    ui.hover = pick(p, pointDots);
    draw();
    lastMouse=p;
  });

  cv.addEventListener('mouseup',(e)=>{
    const p=[e.offsetX*dpr,e.offsetY*dpr];

    if (draggingSelection){
      snapshot();
      draggingSelection=false; dragging=false; dragOriginals=null;
      draw(); updateExport();
      return;
    }

    if (marqueeActive){
      const rect = rectFromPoints(marqueeStart, marqueeEnd);
      const isClick =
        Math.abs(rect.w) < MARQUEE_CLICK_PX*dpr &&
        Math.abs(rect.h) < MARQUEE_CLICK_PX*dpr;

      if (isClick && !e.altKey){
        // click-add a point
        snapshot();
        const L = toLocal(p);
        const S = ui.snap ? snapLocal(L) : L;
        pointDots.push(S);
        setSelection([pointDots.length-1]);
        marqueeActive=false;
        draw(); updateExport();
        return;
      } else {
        // apply marquee selection
        const inside = [];
        for (let i=0;i<pointDots.length;i++){
          const sc = toScreen(pointDots[i]);
          if (pointInRect(sc, rect)) inside.push(i);
        }
        snapshot();
        if (marqueeMode==='replace') setSelection(inside);
        else if (marqueeMode==='add') addSelection(inside);
        else toggleSelection(inside);
        marqueeActive=false;
        draw();
        return;
      }
    }

    draggingCanvas=false;
  });

  cv.addEventListener('mouseleave',()=>{ 
    dragging=false; draggingCanvas=false; draggingSelection=false; marqueeActive=false; 
    // keep rotateActive if holding R; otherwise nothing to do
    dragOriginals=null; 
  });

  cv.addEventListener('wheel',(e)=>{
    // rotate with wheel when holding R; else zoom
    if (rotateActive){
      e.preventDefault();
      let delta = -e.deltaY * 0.002; // fine control
      rotateDelta += delta;
      // snapping if Shift held
      if (e.shiftKey){
        const step = Math.PI/12;
        rotateDelta = Math.round(rotateDelta/step)*step;
      }
      applyRotate(rotateDelta);
      draw(); updateExport();
      return;
    }
    e.preventDefault();
    const k=Math.exp(-e.deltaY*0.001);
    ui.zoom = Math.min(8, Math.max(0.2, ui.zoom*k));
    draw();
  }, {passive:false});

  window.addEventListener('keydown', async (e)=>{
    if (!canUseKeysTarget(e)) return;
    const key = e.key.toLowerCase();

    // Esc cancels marquee or active rotation
    if (key === 'escape'){
      if (rotateActive){ endRotate(false); return; }
      if (marqueeActive){ marqueeActive=false; draw(); return; }
    }

    // Start rotate mode when pressing R (if selection exists)
    if (key==='r' && !rotateActive && selected.size){
      startRotate(); 
      return;
    }

    // Delete selection
    if (key==='backspace' || key==='delete'){
      if (selected.size){
        snapshot();
        const keep = pointDots.filter((_,i)=>!selected.has(i));
        pointDots.length=0; keep.forEach(p=>pointDots.push(p));
        selected.clear();
        draw(); updateExport();
      }
      return;
    }

    // Undo / Redo
    if ((e.ctrlKey||e.metaKey) && key==='z'){
      e.preventDefault();
      if (e.shiftKey){
        if (redoStack.length){
          const cur = { pts: deepCopyPts(pointDots), sel: [...selected] };
          const next = redoStack.pop();
          undoStack.push(cur);
          restore(next);
        }
      } else {
        if (undoStack.length){
          const cur = { pts: deepCopyPts(pointDots), sel: [...selected] };
          const prev = undoStack.pop();
          redoStack.push(cur);
          restore(prev);
        }
      }
      return;
    }

    // Copy
    if ((e.ctrlKey||e.metaKey) && key==='c'){
      const pts = selectedIndices().map(i=>pointDots[i]);
      if (!pts.length) return;
      clipboardPoints = deepCopyPts(pts);
      const ts = pts.map(([x,y])=>`new THREE.Vector2(${x.toFixed(5)}, ${y.toFixed(5)})`).join(',\n');
      navigator.clipboard.writeText(ts).catch(()=>{});
      return;
    }

    // Paste
    if ((e.ctrlKey||e.metaKey) && key==='v'){
      e.preventDefault();
      let text=''; try { text = await navigator.clipboard.readText(); } catch {}
      let cand = parseSeeds(text);
      if (!cand || !cand.length) cand = clipboardPoints ? deepCopyPts(clipboardPoints) : null;
      if (!cand || !cand.length) return;

      const targetLocal = toLocal(lastMouse||[W*0.5,H*0.5]);
      const cx = cand.reduce((a,p)=>a+p[0],0)/cand.length;
      const cy = cand.reduce((a,p)=>a+p[1],0)/cand.length;
      const dx = targetLocal[0]-cx, dy = targetLocal[1]-cy;

      snapshot();
      const startIdx = pointDots.length;
      for (const [x,y] of cand){
        const S = ui.snap? snapLocal([x+dx,y+dy]) : [x+dx,y+dy];
        pointDots.push(S);
      }
      setSelection(Array.from({length:cand.length},(_,k)=>startIdx+k));
      draw(); updateExport();
      return;
    }
  });

  window.addEventListener('keyup', (e)=>{
    if (!canUseKeysTarget(e)) return;
    if (e.key.toLowerCase()==='r'){
      // commit rotation on release
      endRotate(true);
    }
  });

  function pick([sx,sy], list){
    let best=-1, bestD=1e9;
    for (let i=0;i<list.length;i++){
      const [x,y]=toScreen(list[i]); const dx=x-sx, dy=y-sy; const d=Math.hypot(dx,dy);
      if (d<12*dpr && d<bestD){ best=i; bestD=d; }
    }
    return best;
  }

  function rectFromPoints(a,b){
    const x1 = Math.min(a[0], b[0]), y1 = Math.min(a[1], b[1]);
    const x2 = Math.max(a[0], b[0]), y2 = Math.max(a[1], b[1]);
    return {x:x1, y:y1, w:x2-x1, h:y2-y1};
  }
  function pointInRect([x,y], r){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }

  /*** Import parsing ***/
  function loadSeedsFromText(text, doSnapshot){
    const pts = parseSeeds(text);
    if (!pts || !pts.length) { alert('No SEEDS found in provided text.'); return; }
    if (doSnapshot) snapshot();
    pointDots.length = 0;
    pts.forEach(p=>pointDots.push(p));
    selected.clear();
    ui.sel = -1;
    draw();
    updateExport();
  }

  function parseSeeds(text){
    const m = text && text.match(/SEEDS[\s\S]*?=\s*\[([\s\S]*?)\]/);
    if (!m) return null;
    const body = m[1];

    // Preferred: new THREE.Vector2(x, y)
    const reVec2 = /new\s+THREE\.Vector2\s*\(\s*([+-]?\d*\.?\d+(?:e[+-]?\d+)?)\s*,\s*([+-]?\d*\.?\d+(?:e[+-]?\d+)?)\s*\)/gi;
    const out = [];
    let mm;
    while ((mm = reVec2.exec(body)) !== null) {
      out.push([parseFloat(mm[1]), parseFloat(mm[2])]);
    }
    if (out.length) return out;

    // Fallback: array pairs like [x, y]
    const rePair = /\[\s*([+-]?\d*\.?\d+(?:e[+-]?\d+)?)\s*,\s*([+-]?\d*\.?\d+(?:e[+-]?\d+)?)\s*\]/g;
    while ((mm = rePair.exec(body)) !== null) {
      out.push([parseFloat(mm[1]), parseFloat(mm[2])]);
    }
    return out;
  }

  /*** Copy/Paste clipboard (in-memory fallback) ***/
  let clipboardPoints = null;

  /*** Render ***/
  function draw(){
    ctx.clearRect(0,0,W,H);
    grid();
    // axes
    line([toScreen([-1000,0]), toScreen([1000,0])], '#fff');
    line([toScreen([0,-1000]), toScreen([0,1000])], '#fff');

    // points
    for (let i=0;i<pointDots.length;i++){
      const p = toScreen(pointDots[i]);
      const isSel = selected.has(i);
      circle(p, isSel ? 6 : 5, isSel ? '#fff' : '#4da6ff');
    }

    // selection bbox (axis-aligned) for current selection
    const bbox = selectionBBoxScreen();
    if (bbox){
      ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.lineWidth=1;
      ctx.setLineDash([4,3]);
      ctx.strokeRect(bbox.minX, bbox.minY, bbox.maxX-bbox.minX, bbox.maxY-bbox.minY);
      ctx.setLineDash([]);
    }

    // rotate overlay
    if (rotateActive){
      const ps = toScreen(rotatePivotLocal);
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = 1;
      // pivot crosshair
      ctx.beginPath();
      ctx.moveTo(ps[0]-6, ps[1]); ctx.lineTo(ps[0]+6, ps[1]);
      ctx.moveTo(ps[0], ps[1]-6); ctx.lineTo(ps[0], ps[1]+6);
      ctx.stroke();
      // angle readout
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.font = '12px ui-sans-serif';
      ctx.fillText((rotateDelta*180/Math.PI).toFixed(1) + '°', ps[0]+8, ps[1]-8);
    }
  }
  function grid(){
    const step = ui.unit*ui.zoom*0.5;
    const ox = (W*0.5 + ui.pan.x*dpr) % step;
    const oy = (H*0.5 + ui.pan.y*dpr) % step;
    ctx.strokeStyle='#5f656e'; ctx.lineWidth=1;
    ctx.beginPath();
    for (let x=ox; x<=W; x+=step){ ctx.moveTo(x,0); ctx.lineTo(x,H); }
    for (let y=oy; y<=H; y+=step){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
    ctx.stroke();
  }
  function line([[x1,y1],[x2,y2]], col){ ctx.strokeStyle=col; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
  function circle([x,y], r, col){ ctx.fillStyle=col; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }

  /*** Export helpers ***/
  function normalizePts(pts){
    if (!ui.normalize || !pts.length) return pts.slice();
    let minX=+1e9, minY=+1e9, maxX=-1e9, maxY=-1e9;
    for (const [x,y] of pts){ if (x<minX) minX=x; if (x>maxX) maxX=x; if (y<minY) minY=y; if (y>maxY) maxY=y; }
    const cx=(minX+maxX)/2, cy=(minY+maxY)/2;
    const sx = Math.max(1e-6, (maxX-minX)/2);
    const sy = Math.max(1e-6, (maxY-minY)/2);
    const s = Math.max(sx, sy); // keep aspect
    return pts.map(([x,y])=>[ (x-cx)/s, (y-cy)/s ]);
  }

  /*** Export (Points -> exact placements) ***/
  function updateExport() {
    const exported = normalizePts(pointDots);
    const vec2 = ([x,y]) => `  new THREE.Vector2(${(+x).toFixed(5)}, ${(+y).toFixed(5)})`;
    const vecs = exported.map(vec2).join(',\n');

    const code = `// AUTO-GENERATED BY shape-gen.html (Points mode)
import * as THREE from 'three';
import type { Pattern } from '@/features/cardGroup/patterns';

/** Exact, author-placed points in local [-1..1] coords (unitless). */
const SEEDS: THREE.Vector2[] = [
${vecs}
];

const pattern: Pattern = {
  fixedCount: SEEDS.length,
  sample() {
    const positions = SEEDS.map(v => new THREE.Vector3(v.x, v.y, 0));
    return { positions };
  }
};

export default pattern;
`;
    $out.textContent = code;
  }

  // seed initial history
  snapshot();
  resize();
  draw();
  updateExport();
})();
</script>
</body>
</html>
